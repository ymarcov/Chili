 .................................
//+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^+\\
[+'''''''''''''''''''''''''''''''+]
[|                               |]
[|    Asynchronous Processing    |]
[|                               |]
[+...............................+]
\\+vvvvvvvvvvvvvvvvvvvvvvvvvvvvv+//
 '''''''''''''''''''''''''''''''''

Upon receiving a request, add support for
asynchronous processing of response data.


.============.
|            |
|  Contents  |
|            |
'============'

1. Motivation
2. Requirements
3. Preparation
4. Architecture
5. Specification
6. Optimizations
7. Use Cases
8. Workplan


.=================.
|                 |
|  1. Motivation  |
|                 |
'================='

In some cases, generating response data for incoming requests is either
immediate, when no processing is needed, or quick enough, when relatively
little processing is needed. In other cases, processing can take quite
a while, to such an extent that the threads responsible for responding
to requests may be blocked and thus decrease both latency and throughput
unnecessarily. If these blocks can be avoided, while processing happens
in the background, these threads can keep serving more responses--some
of which may not require much processing, and should therefore not be
required to wait in line for other requests that do.


.===================.
|                   |
|  2. Requirements  |
|                   |
'==================='

[2.1] Non-asynchronous flows should not suffer a performance penalty
      greater than 5% as a result of potential architectural changes.

[2.2] Channels should be able to request background processing, enter
      a waiting mode until that processing is complete, and be woken
      up when it is, receiving any resulting data from that processing.

[2.3] Channels should be able to request multiple background processing
      tasks per one incoming request.

[2.4] Channels should be able to initiate background processing upon
      receiving only the header of an incoming request.

[2.5] The result of any processing done on a channel that has been
      closed since requesting it should be discarded safely.

[2.6] Channels should not be held alive in memory if, after having
      been closed, their requested processing has not yet finished.

[2.7] A channel may have, at most, only one pending task at any moment.


.==================.
|                  |
|  3. Preparation  |
|                  |
'=================='

[3.1] The subclass Channel should merge into its base, ChannelBase,
      to create just one class named Channel, and should enable
      shared_from_this().

[3.2] Processing that follows a conditional fetching of message body should
      be provided as a callback function, such that the Process() function
      is called, at most, only once per request.

[3.3] Log::Default()->*() should be changed to simply Log::*().

[3.4] Responding with stream should support waking up the channel
      instead of blocking while waiting for stream data.


.===================.
|                   |
|  4. Architecture  |
|                   |
'==================='

[4.1] Components:

  [4.1.1] Channel: An HTTP session between the server and a client.

  [4.1.2] Exchange: Manages a request/response exchange, and allows
          for reading the request and creating a response, as well
          as coordinating background processing of the request.

  [4.1.3] Orchestrator: Coordinates the transition of channels between
          their various stages: reading, writing, processing, etc.

  [4.1.4] ProcessingThreadPool: A ThreadPool instance belonging to the
          Orchestrator, responsible for processing background tasks
          submitted by channels.

[4.2] Interaction:

  [4.2.1] A Channel sends a task for execution through an Exchange.
          The task either contains instructions to await another Task,
          or to conclude the Exchange with a response.

          * If neither instruction is included, a fatal logic
            error is logged and the entire server is crashed.

  [4.2.2] The Exchange sets the Channel's stage to WaitProcessable.

  [4.2.3] The ProcessingThreadPool, when ready to execute the Task,
          by means of instructions injected by the Exchange which
          wrap the original task, sets the Channel's stage
          to Process and executes the Task.

          * If any exception is thrown during the execution of the Task,
          an Internal Server Error is sent to the client. If the Channel
          has already been closed, nothing happens.

  [4.2.4] Upon concluding the Exchange, the Channel's stage is set to
          Write, and the Orchestrator is woken up to send the response.

[4.3] Ownership:

  [4.3.1] An Exchange holds a weak_ptr to its corresponding Channel.

  [4.3.2] A Channel is normally owned by the Orchestrator, but its ownership
          is shared with a task awaited by its Exchange only while the task's
          dispatch or execution steps need to have temporary access to it.

  [4.3.3] A task wrapper, created by an Exchange and processed by the
          ProcessingThreadPool, owns a shared_ptr to that Exchange.


.====================.
|                    |
|  5. Specification  |
|                    |
'===================='

[5.1] Class Additions:

  [5.1.1] Exchange

          - GetRequest() : shared_ptr<Request> (owning Channel)
              : Gets the current request or throws an exception.

          - TryGetRequest() : shared_ptr<Request> (owning Channel)
              : Gets the current request or returns null.

          - CreateResponse() : shared_ptr<Response> (owning Channel)
              : Creates a new response or throws an exception.

          - TryCreateResponse() : shared_ptr<Response> (owning Channel)
              : Creates a new response or returns null.

          - Await(function<Action()>) : AwaitAction
              : Executes the function, which itself must return the result
                of either another Await() or a Conclude().

          - Conclude(shared_ptr<Response>) : ConcludeAction
              : Concludes the exchange with the specified response.

          + Channel : weak_ptr<Channel>
          + Orchestrator : Orchestrator*

[5.2] Class Modifications:

  [5.2.1] Orchestrator
          + ProcessingThreadPool : ThreadPool

.====================.
|                    |
|  6. Optimizations  |
|                    |
'===================='

[6.1] As the number of threads increases, add an auto-scaling algorithm
     for live-thread management to the ThreadPool, given its capacity.


.================.
|                |
|  7. Use Cases  |
|                |
'================'

[7.1] A Channel receives a request and immediately determines the response.

[7.2] A Channel receives the headers of a request and asks to fetch its body.
      When its body is fetched, it determines the response.

[7.3] A Channel receives a request and needs additional processing to occur
      before a response can be sent. It awaits that processing and, when
      it's ready, determines the response.

[7.4] A Channel receives the headers of a request and asks to fetch its body.
      After its body is fetched, it needs additional processing to occur
      before a response can be sent. It awaits that processing and, when
      it's ready, determines the response.

[7.5] A Channel receives a request and needs additional processing to occur
      before a response can be sent. While that processing executes, it
      needs additional processing to occur before determining a response.
      That processing awaits additional processing and, when it's ready,
      determines the response.

[7.6] A Channel receives the headers of a request and asks to fetch its body.
      After its body is fetched, it needs additional processing to occur
      before a response can be sent. While that processing executes, it
      needs additional processing to occur before determining a response.
      That processing awaits additional processing and, when it's ready,
      determines the response.


.===============.
|               |
|  8. Workplan  |
|               |
'==============='

[8.1] Complete all preparation steps.

[8.2] Create Exchange class that doesn't yet support async execution,
      and change all processors to use its synchronized API.

[8.2] Create ExecutionService and Task.

[8.3] Add asynchronous API to Exchange.

===END===

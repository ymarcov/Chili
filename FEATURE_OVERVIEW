.++++++++++++++++++++++++++++.
| Profiler: Feature Overview |
'++++++++++++++++++++++++++++'

.------------.
| Motivation |
'------------'

Some problems are very hard to debug, because the server
is mostly asynchronous, and handles lots and lots of work
in parallel and very quickly. Using a sampling profiler,
like perf, reveals Heisenbugs which cannot be debugged
with such means. Therefore, a tracer is proposed here
that will log important events in the system that would
help in identifying and analyzing strange behavior.

.--------------.
| Requirements |
'--------------'

  1) Know how much time each channel was:
       - In each stage
       - Throttled

  2) Know how much work has been done for
     lexing and parsing per channel.

  3) Know how long the orchestrator was awake vs. asleep.

.-------------------.
| Feature Proposals |
'-------------------'

  1) Profile whenever a channel's stage changes.


.-------------------.
| Design Guidelines |
'-------------------'

  1) Custom events per component. Events should be easy
     to add and hopefully to modify or remove.
     Events should be structured, but flexible in terms
     of the data they carry.

.--------.
| Design |
'--------'

  ProfileEvent
  ============
    ProfileEvent() # sets time point
    # virtual string GetSource() const = 0
    # virtual string GetSummary() const = 0
    # const time_point& GetTimePoint() const
    # virtual void Accept(ProfileReader&) = 0


  Profile
  =======
    # vector<const ProfileEvent*> GetEvents() const


  Profiler
  ========
    # void Record(unique_ptr<ProfileEvent>)


  ProfileReader
  =============
    # virtual void Read(* : ProfileEvent&) {}


.---------.
| Example |
'---------'

  struct ChannelEvent : ProfileEvent {
    ChannelEvent(const char* source, int channelId)
        : _source(source)
        , ChannelId(channelId) {}

    string GetSource() const override {
        return _source;
    }

    const char* _source;
    int ChannelId;
  }

  struct ChannelReadable : ChannelEvent {
    using ChannelEvent::ChannelEvent;

    string GetSummary() const override {
        fmt::format("Channel {} became readable", _channelId);
    }

    void Accept(ProfileReader& pr) override {
        pr.Read(*this);
    }
  }

  ...

  Profiler& p;

  p.Record(make_unique<ChannelReadable>("AbstractChannel", _id));

  ...

  struct MyProfileReader : ProfileReader {
      void Read(ChannelEvent& e) override {
          ++_channelEvents;
          Log::Default()->Info("Event on channel {}", e.ChannelId);
          e.Accept(_channelEventReader);
      }
  }
